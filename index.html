<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Isovist — Marais (Overpass → GeoJSON → WebMercator)</title>
<style>
  :root{
    --bg:#071022;
    --panel:#0b1220;
    --accent:#22c1c3;
    --muted:#94a3b8;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .container{display:flex;gap:12px;height:100%;padding:12px;box-sizing:border-box}
  #canvasWrap{flex:1;border-radius:10px;background:linear-gradient(180deg,#071022,#05111b);box-shadow:0 8px 30px rgba(2,6,23,0.6);position:relative;overflow:hidden}
  canvas{width:100%;height:100%;display:block}
  .panel{width:360px;background:var(--panel);border-radius:10px;padding:14px;box-sizing:border-box;display:flex;flex-direction:column;gap:12px}
  h1{margin:0;font-size:16px}
  .controls{display:flex;flex-direction:column;gap:8px}
  label{font-size:13px;color:var(--muted)}
  input[type="range"]{width:100%}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:var(--accent);cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  .footer{margin-top:auto;font-size:12px;color:var(--muted)}
  .status{font-size:13px;color:var(--muted);padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .danger{color:#ff7b7b}
  .success{color:#7bffdf}
</style>
</head>
<body>
<div class="container">
  <div id="canvasWrap">
    <canvas id="c"></canvas>
  </div>

  <div class="panel">
    <h1>Isovist — Le Marais (OSM → GeoJSON)</h1>

    <div class="controls">
      <div class="small">BBox utilisée (Le Marais) :</div>
      <pre class="small" style="margin:0;background:transparent">south: 48.852, west: 2.349, north: 48.868, east: 2.366</pre>

      <div style="display:flex;gap:8px">
        <button id="fetchBtn">Récupérer bâtiments (Overpass)</button>
        <button id="clearBtn">Effacer polygones</button>
      </div>

      <div class="status" id="status">Aucune donnée chargée.</div>

      <label>Nombre de rayons : <span id="rayCountLabel">720</span></label>
      <input id="rayCount" type="range" min="60" max="2048" step="10" value="720">

      <label>Rayon max (distance max vue) : <span id="maxDistLabel">1200</span> px</label>
      <input id="maxDist" type="range" min="200" max="3000" step="50" value="1200">

      <div style="display:flex;gap:8px">
        <button id="toggleRays">Basculer rayons</button>
        <button id="zoomFit">Ajuster vue</button>
      </div>

      <div class="small">Astuce : déplace la souris sur la carte — l'isovist suit le curseur.</div>
    </div>

    <div class="footer">
      <div class="small">Prototype — Projection WebMercator & isovist 2D</div>
      <div class="small" style="margin-top:6px">Si tu as un problème CORS, lance le script Node ou curl côté serveur (je peux fournir si tu veux).</div>
    </div>
  </div>
</div>

<!-- osmtogeojson CDN -->
<script src="https://unpkg.com/osmtogeojson@3.0.0/osmtogeojson.js" defer></script>
<script>
  document.addEventListener('DOMContentLoaded', ()=>{
/*
  Page autonome:
  - POST Overpass (bbox Marais)
  - osmtogeojson convert
  - WebMercator projection lon/lat -> pixels
  - inject polygons in simulator isovist (ray-casting)
  - isovist follows mouse
*/

// Canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let DPR = Math.min(window.devicePixelRatio || 1, 2);
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width * DPR);
  canvas.height = Math.round(rect.height * DPR);
}
window.addEventListener('resize', () => { resizeCanvas(); draw(); });
resizeCanvas();

// UI elements
const fetchBtn = document.getElementById('fetchBtn');
const clearBtn = document.getElementById('clearBtn');
const statusEl = document.getElementById('status');
const rayCountEl = document.getElementById('rayCount');
const rayCountLabel = document.getElementById('rayCountLabel');
const maxDistEl = document.getElementById('maxDist');
const maxDistLabel = document.getElementById('maxDistLabel');
const toggleRaysBtn = document.getElementById('toggleRays');
const zoomFitBtn = document.getElementById('zoomFit');

rayCountLabel.textContent = rayCountEl.value;
maxDistLabel.textContent = maxDistEl.value;

rayCountEl.addEventListener('input', ()=>{ rayCountLabel.textContent = rayCountEl.value; draw(); });
maxDistEl.addEventListener('input', ()=>{ maxDistLabel.textContent = maxDistEl.value; draw(); });

let showRays = true;
toggleRaysBtn.addEventListener('click', ()=>{ showRays = !showRays; draw(); });

// bbox for Le Marais (modifiable)
const BBOX = { south: 48.852, west: 2.349, north: 48.868, east: 2.366 };

// Overpass query
const overpassQuery = `[out:json][timeout:60];
(
  way["building"](${BBOX.south},${BBOX.west},${BBOX.north},${BBOX.east});
  relation["building"](${BBOX.south},${BBOX.west},${BBOX.north},${BBOX.east});
);
out body;
>;
out skel qt;`;

// Projection: WebMercator (meters)
const R = 6378137;
function lonLatToMercator(lon, lat){
  const x = R * lon * Math.PI / 180;
  const y = R * Math.log(Math.tan(Math.PI/4 + (lat * Math.PI/180)/2));
  return {x,y};
}

// Variables for mapping mercator -> canvas pixels
let mercBBox = null; // {minX,maxX,minY,maxY}
let mapPadding = 24; // px
function computeMercBBoxFromGeojson(geojson){
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(const feat of geojson.features || []){
    const geom = feat.geometry;
    if(!geom) continue;
    const polys = (geom.type === 'Polygon') ? [geom.coordinates] : (geom.type === 'MultiPolygon' ? geom.coordinates : []);
    for(const poly of polys){
      // poly is array of linear rings; use outer ring (0)
      const ring = poly[0];
      for(const coord of ring){
        const lon = coord[0], lat = coord[1];
        const m = lonLatToMercator(lon, lat);
        if(m.x < minX) minX = m.x;
        if(m.x > maxX) maxX = m.x;
        if(m.y < minY) minY = m.y;
        if(m.y > maxY) maxY = m.y;
      }
    }
  }
  // in case nothing found, fallback to bbox projection
  if(minX === Infinity){
    const sw = lonLatToMercator(BBOX.west, BBOX.south);
    const ne = lonLatToMercator(BBOX.east, BBOX.north);
    minX = Math.min(sw.x, ne.x); maxX = Math.max(sw.x, ne.x);
    minY = Math.min(sw.y, ne.y); maxY = Math.max(sw.y, ne.y);
  }
  mercBBox = { minX, maxX, minY, maxY };
}

// mercator to pixel
function mercatorToPixel(mx, my){
  const W = canvas.width / DPR, H = canvas.height / DPR;
  const pad = mapPadding;
  const minX = mercBBox.minX, maxX = mercBBox.maxX, minY = mercBBox.minY, maxY = mercBBox.maxY;
  const sx = (W - pad*2) / (maxX - minX);
  const sy = (H - pad*2) / (maxY - minY);
  const s = Math.min(sx, sy);
  // center alignment
  const widthMapped = (maxX - minX) * s;
  const heightMapped = (maxY - minY) * s;
  const offsetX = (W - widthMapped) / 2;
  const offsetY = (H - heightMapped) / 2;
  const px = offsetX + (mx - minX) * s;
  // invert y because mercator y increases north, canvas y increases down
  const py = offsetY + (maxY - my) * s;
  return {x: px, y: py};
}

// Convert GeoJSON features -> polygons in pixel coords for simulator
function geojsonToPixelPolygons(geojson){
  const polys = [];
  for(const feat of geojson.features || []){
    const geom = feat.geometry;
    if(!geom) continue;
    if(geom.type === 'Polygon'){
      const outer = geom.coordinates[0];
      const ring = outer.map(c => {
        const m = lonLatToMercator(c[0], c[1]);
        const p = mercatorToPixel(m.x, m.y);
        return {x: p.x, y: p.y};
      });
      // optionally discard tiny polygons
      if(ring.length >= 3) polys.push(fixPolygonWinding(ring));
    } else if(geom.type === 'MultiPolygon'){
      for(const poly of geom.coordinates){
        const outer = poly[0];
        const ring = outer.map(c => {
          const m = lonLatToMercator(c[0], c[1]);
          const p = mercatorToPixel(m.x, m.y);
          return {x: p.x, y: p.y};
        });
        if(ring.length >= 3) polys.push(fixPolygonWinding(ring));
      }
    }
  }
  return polys;
}

// Ensure polygon is non-self-intersecting ordering (we assume it's ordered but ensure clockwise/ccw consistent).
function fixPolygonWinding(ring){
  // compute signed area
  let area = 0;
  for(let i=0;i<ring.length;i++){
    const a = ring[i], b = ring[(i+1)%ring.length];
    area += (a.x*b.y - b.x*a.y);
  }
  // area > 0 => CCW in canvas coords? We'll simply ensure CCW
  if(area < 0) ring.reverse();
  return ring;
}

/* --------------------
   Isovist simulator adapted (from le prototype précédent)
-------------------- */
let polygons = []; // polygons in pixel coords
let observer = {x: canvas.width/2/DPR, y: canvas.height/2/DPR};
let showPolygonsOutline = true;

// build segments for collision checks
function getSegmentsFromPolygons(polys){
  const segs = [];
  for(const poly of polys){
    for(let i=0;i<poly.length;i++){
      const a = poly[i];
      const b = poly[(i+1)%poly.length];
      segs.push({a:{x:a.x,y:a.y}, b:{x:b.x,y:b.y}});
    }
  }
  return segs;
}

// intersection using vector cross method
function intersectRaySeg2(px,py, dirx,diry, x1,y1,x2,y2){
  const ax = x1, ay = y1;
  const bx = x2, by = y2;
  const dx = dirx, dy = diry;
  const vx = bx - ax, vy = by - ay;
  const denom = dx*vy - dy*vx;
  if (Math.abs(denom) < 1e-9) return null;
  const t = ( (ax - px)*vy - (ay - py)*vx ) / denom;
  const u = ( (ax - px)*dy - (ay - py)*dx ) / denom;
  if(t >= 0 && u >= 0 && u <= 1){
    return { x: px + t*dx, y: py + t*dy, t: t, u: u };
  }
  return null;
}

function computeIsovist(origin, numRays, maxDist){
  const pts = [];
  const segs = getSegmentsFromPolygons(polygons);
  for(let i=0;i<numRays;i++){
    const ang = (i/numRays) * Math.PI * 2;
    const dx = Math.cos(ang);
    const dy = Math.sin(ang);

    let nearest = null;
    let nearestT = Infinity;
    for(const s of segs){
      const it = intersectRaySeg2(origin.x, origin.y, dx, dy, s.a.x, s.a.y, s.b.x, s.b.y);
      if(it && it.t < nearestT){
        nearestT = it.t;
        nearest = {x: it.x, y: it.y};
      }
    }

    if(nearest){
      const dist = Math.hypot(nearest.x - origin.x, nearest.y - origin.y);
      if(dist > maxDist) pts.push({x: origin.x + dx*maxDist, y: origin.y + dy*maxDist});
      else pts.push(nearest);
    } else {
      pts.push({x: origin.x + dx*maxDist, y: origin.y + dy*maxDist});
    }
  }
  return pts;
}

/* --------------------
   Drawing
-------------------- */
function clear(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#05111b';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

function drawGrid(){
  const W = canvas.width/DPR, H = canvas.height/DPR;
  const step = 100;
  ctx.save();
  ctx.scale(DPR, DPR);
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let x=0;x<=W;x+=step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  for(let y=0;y<=H;y+=step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }
  ctx.restore();
}

function draw(){
  resizeCanvas();
  clear();
  ctx.save();
  ctx.scale(DPR, DPR);

  drawGrid();

  // draw polygons (bâtiments)
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.fillStyle = 'rgba(200,210,220,0.06)';
  for(const poly of polygons){
    ctx.beginPath();
    for(let i=0;i<poly.length;i++){
      const p = poly[i];
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  const numRays = parseInt(rayCountEl.value,10);
  const maxDist = parseFloat(maxDistEl.value,10);

  const isoPts = computeIsovist(observer, numRays, maxDist);

  if(isoPts && isoPts.length>2){
    ctx.beginPath();
    ctx.moveTo(isoPts[0].x, isoPts[0].y);
    for(let i=1;i<isoPts.length;i++) ctx.lineTo(isoPts[i].x, isoPts[i].y);
    ctx.closePath();
    const g = ctx.createRadialGradient(observer.x, observer.y, 1, observer.x, observer.y, Math.min(maxDist, Math.hypot(canvas.width,canvas.height)));
    g.addColorStop(0, 'rgba(34,193,195,0.18)');
    g.addColorStop(1, 'rgba(34,193,195,0.02)');
    ctx.fillStyle = g;
    ctx.fill();
    ctx.strokeStyle = 'rgba(34,193,195,0.9)';
    ctx.lineWidth = 1.2;
    ctx.stroke();
  }

  if(showRays){
    ctx.lineWidth = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.beginPath();
    for(const p of isoPts){
      ctx.moveTo(observer.x, observer.y);
      ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }

  // draw observer
  ctx.beginPath();
  ctx.fillStyle = '#fff';
  ctx.arc(observer.x, observer.y, 4, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.strokeStyle = '#0b1220';
  ctx.lineWidth = 2;
  ctx.arc(observer.x, observer.y, 6, 0, Math.PI*2);
  ctx.stroke();

  // outlines
  if(showPolygonsOutline){
    ctx.lineWidth = 0.9;
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    for(const poly of polygons){
      ctx.beginPath();
      for(let i=0;i<poly.length;i++){
        const p = poly[i];
        if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
      }
      ctx.closePath();
      ctx.stroke();
    }
  }

  ctx.restore();
}

/* --------------------
   Mouse handling: isovist follows mouse
-------------------- */
canvas.addEventListener('pointermove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width) / DPR;
  const y = (e.clientY - rect.top) * (canvas.height / rect.height) / DPR;
  observer.x = x;
  observer.y = y;
  // optional performance trick: fewer rays while pointer moves — not implemented now
  draw();
});

canvas.addEventListener('contextmenu', (e)=>e.preventDefault());

/* --------------------
   Fetch Overpass -> convert -> project -> inject
-------------------- */
async function fetchOverpass(){
  statusEl.textContent = 'Récupération des bâtiments depuis Overpass…';
  statusEl.className = 'status';
  try{
    const res = await fetch('https://overpass-api.de/api/interpreter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' },
      body: 'data=' + encodeURIComponent(overpassQuery)
    });
    if(!res.ok){
      throw new Error(`Overpass HTTP ${res.status} ${res.statusText}`);
    }
    const osmJson = await res.json();
    // convert
    const geojson = osmtogeojson(osmJson);
    if(!geojson || !geojson.features || geojson.features.length === 0){
      statusEl.innerHTML = '<span class="danger">Aucune feature retournée par Overpass.</span>';
      polygons = [];
      draw();
      return;
    }
    // compute mercator bbox & project
    computeMercBBoxFromGeojson(geojson);
    polygons = geojsonToPixelPolygons(geojson);
    if(polygons.length === 0){
      statusEl.innerHTML = '<span class="danger">Conversion OK mais aucun polygon utilisable.</span>';
    } else {
      statusEl.innerHTML = '<span class="success">Chargé : ' + polygons.length + ' polygones (bâtiments).</span>';
      // center observer in the middle of map area
      const midX = (mercBBox.minX + mercBBox.maxX)/2;
      const midY = (mercBBox.minY + mercBBox.maxY)/2;
      const midP = mercatorToPixel(midX, midY);
      observer.x = midP.x; observer.y = midP.y;
      draw();
    }
  } catch(err){
    console.error(err);
    statusEl.innerHTML = `<span class="danger">Erreur: ${escapeHtml(err.message || String(err))} — possible CORS ou indisponibilité Overpass.</span>`;
    // fallback: nothing
  }
}

fetchBtn.addEventListener('click', async ()=>{
  await fetchOverpass();
});

clearBtn.addEventListener('click', ()=>{
  polygons = [];
  statusEl.textContent = 'Polygones effacés.';
  draw();
});

zoomFitBtn.addEventListener('click', ()=>{
  if(!mercBBox) return;
  // center observer to map center
  const midX = (mercBBox.minX + mercBBox.maxX)/2;
  const midY = (mercBBox.minY + mercBBox.maxY)/2;
  const midP = mercatorToPixel(midX, midY);
  observer.x = midP.x; observer.y = midP.y;
  draw();
});

// small HTML-escape helper for status
function escapeHtml(s){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// initial draw
draw();
});
</script>
</body>
</html>
