<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Urban Sight - Explorez la Perm√©abilit√© Visuelle des Espaces en Temps R√©el</title>


<meta name="robots" content="index, follow">
<meta name="keywords" content="Perm√©abilit√© Visuelle, Carte, Ga√´l Maignan, Urbanisme sensible, SIG, GIS, urbanisme">


<link rel="canonical" href="https://urban-sight.pages.dev/">


<!-- Merge/topojson (conserve ton merge.js si n√©cessaire) -->
<script src="https://unpkg.com/topojson-server@3.0.1/dist/topojson-server.min.js"></script>
<script src="https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
<script src="merge.js"></script>

<script type="module" src="https://gael-mgn.github.io/js/log.js"></script>

<link rel="icon" type="image/png" href="favicon.png" />


    <meta property="og:title" content="Urban Sight - Explorez la Perm√©abilit√© Visuelle des Espaces en Temps R√©el">
    <meta property="og:description" content="La perm√©abilit√© visuelle d√©signe la capacit√© d'un espace √† permettre √† la vue de circuler librement, offrant ainsi une connexion visuelle entre diff√©rentes zones.">
    <meta property="og:url" content="https://urban-sight.pages.dev/">
<meta property="og:type" content="website">

    <meta property="og:image" content="https://urban-sight.pages.dev/urban-sight.webp">


<script>
  // ----------------- LIMITES DE ZOOM (en m√®tres, WebMercator) -----------------
const MIN_VIEW_WIDTH_METERS = 2.0;          // limite de zoom avant (ne pas zoomer plus pr√®s)
const MAX_VIEW_WIDTH_METERS = 2_500;    // limite de d√©zoom (ex : ~5 000 km). Ajuste si n√©cessaire.
// seuil relatif minimal de changement pour d√©clencher un redraw (ex: 0.1%)
const ZOOM_REL_CHANGE_THRESHOLD = 0.01; // 0.1% : ajuste si tu veux √™tre plus/moins permissif
// d√©lai d'inactivit√© apr√®s wheel avant d'actualiser les b√¢timents (ms)
const WHEEL_IDLE_DELAY_MS = 520; // ajuste (200-300ms couramment)



// ----------------------------------------------------------------------------


  async function fetchWithRetry(url, options = {}, retries = 4, delay = 1000) {
    let attempts = 0;

    while (attempts < retries) {
        try {
            // On essaie de r√©cup√©rer les donn√©es via fetch
            const response = await fetch(url, options);

            // Si la r√©ponse est ok (status 200-299), on renvoie la r√©ponse
            if (response.ok) {
                return response;
            } else {
                // Si la r√©ponse n'est pas ok, on lance une erreur
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            attempts++;

            if (attempts >= retries) {
                // Si le nombre d'essais est √©puis√©, on lance l'erreur finale
                throw new Error(`Failed after ${retries} attempts: ${error.message}`);
            }

            // Attendre un certain d√©lai avant de r√©essayer
            console.log(`Attempt ${attempts} failed. Retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

</script>

<style>
  /* cache le curseur quand il est au-dessus du canvas */
#canvasWrap canvas {
  cursor: none;
}
  :root{
    --bg:#071022;
    --panel:#0b1220;
    --accent:#22c1c3;
    --muted:#94a3b8;
  }
  a {
    color: var(--accent);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .container{display:flex;gap:12px;height:100%;padding:12px;box-sizing:border-box}
  #canvasWrap{flex:1;border-radius:10px;background:linear-gradient(180deg,#071022,#05111b);box-shadow:0 8px 30px rgba(2,6,23,0.6);position:relative;overflow:hidden}
  canvas{width:100%;height:100%;display:block;touch-action: none} /* prevent default gestures */
  .panel{width:360px;background:var(--panel);border-radius:10px;padding:14px;box-sizing:border-box;display:flex;flex-direction:column;gap:12px}
  h1{margin:0;font-size:20px}
  h2{font-size:16px}
  .controls{display:flex;flex-direction:column;gap:8px}
  label{font-size:13px;color:var(--muted)}
  input[type="range"]{width:100%}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:var(--accent);cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  .footer{margin-top:auto;font-size:12px;color:var(--muted)}
  .status{font-size:13px;color:var(--muted);padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .danger{color:#ff7b7b}
  .success{color:#7bffdf}

  /* search bar overlay (ajoute au style existant) */
#canvasWrap { position: relative; } /* d√©j√† n√©cessaire pour position absolute */
.searchBar{
  position: absolute;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  display:flex;
  gap:8px;
  align-items:center;
  background: rgba(11,18,32,0.88);
  padding:6px 10px;
  border-radius:10px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.6);
  z-index: 50;
  backdrop-filter: blur(4px);
  border: 1px solid rgba(255,255,255,0.04);
}
.searchBar input{
  width:360px;
  max-width: calc(100vw - 160px);
  padding:8px 10px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.04);
  background: rgba(255,255,255,0.02);
  color: #e6eef6;
  font-size:14px;
  outline: none;
}
.searchBar input::placeholder{ color: rgba(230,238,246,0.45); }
.searchBar button{
  padding:8px 10px;
  border-radius:8px;
  border: none;
  background: transparent;
  cursor: pointer;
  font-size:16px;
  color: var(--accent);
}
.searchBar button:active{ transform: translateY(1px); }











/* ======================
   Loader overlay (ajouter ici)
   ====================== */
#loaderOverlay{
  position: absolute;
  inset: 0;                 /* top:0; right:0; bottom:0; left:0; */
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(2,6,12,0.6);
  z-index: 60;
  pointer-events: auto;
  transition: opacity 220ms ease, visibility 220ms ease;
  opacity: 1;
  visibility: visible;
  backdrop-filter: blur(4px);
}

#loaderOverlay.hidden{
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

/* card */
.loader-box{
  display:flex;
  gap:12px;
  align-items:center;
  background: rgba(11,18,32,0.95);
  padding: 12px 16px;
  border-radius: 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6);
  border: 1px solid rgba(255,255,255,0.04);
}

/* spinner */
.loader-spinner{
  width:34px;
  height:34px;
  border-radius:50%;
  border:4px solid rgba(255,255,255,0.08);
  border-top-color: var(--accent);
  animation: loader-rot 1s linear infinite;
  box-sizing:border-box;
}

@keyframes loader-rot{
  to { transform: rotate(360deg); }
}

.loader-text{
  font-size:14px;
  color: #e6eef6;
  min-width:160px;
}


</style>
</head>
<body>
<div class="container">
  <div id="canvasWrap">
     <div class="searchBar" id="searchBar">
    <input id="addressInput" type="search"
           placeholder="Rechercher une adresse (ex : 80 Rue Rebeval, Paris)" />
    <button id="addressSearchBtn" aria-label="Rechercher">üîç</button>
      </div>
       <!-- INS√àREZ CE BLOC JUSTE ICI (avant le <canvas>) -->
     <div id="loaderOverlay" class="hidden" role="status" aria-live="polite" aria-hidden="true">
       <div class="loader-box">
         <div class="loader-spinner" aria-hidden="true"></div>
         <div class="loader-text">Chargement des b√¢timents‚Ä¶</div>
       </div>
     </div>
    <canvas id="c"></canvas>
  </div>

  <div class="panel">
    <h1>Visualisation de la Perm√©abilit√© Visuelle</h1>

    <div class="controls">
      <!--<div class="small">BBox utilis√©e (Le Marais) :</div>
      <pre class="small" style="margin:0;background:transparent">south: 48.852, west: 2.349, north: 48.868, east: 2.366</pre>-->


      <div class="status" id="status">Aucune donn√©e charg√©e.</div>

      <label>Nombre de rayons : <span id="rayCountLabel"></span></label>
      <input id="rayCount" type="range" min="20" max="500" step="10" value="150">

      <label>Rayon max (distance max vue) : <span id="maxDistLabel"></span> m</label>
      <input id="maxDist" type="range" min="20" max="400" step="10" value="120">

      <div style="display:flex;gap:8px;display: none;">
        <button id="zoomFit">Ajuster vue</button>
      </div>

      <!-- ====== Toggle des arbres (INSERER DANS .controls) ====== -->
<label style="display:flex;align-items:center;gap:8px;">
  <input id="toggleTrees" type="checkbox" checked />
  <span class="small">Afficher les arbres</span>
</label>


      <h2>√Ä propos de la Perm√©abilit√© Visuelle</h2>

      <div class="small">La perm√©abilit√© visuelle d√©signe la capacit√© d'un espace √† permettre √† la vue de circuler librement, offrant ainsi une connexion visuelle entre diff√©rentes zones. Elle influence la perception de l'espace, l'intimit√© et la circulation des utilisateurs.</div>


      <h2>√âtude de la perm√©abilit√© Visuelle</h2>

      <div class="small">Je d√©veloppe √©galement un outil permettant de quantifier la perm√©abilit√© visuelle d‚Äôune zone g√©ographique donn√©e, dans la perspective de mener une analyse √† l‚Äô√©chelle de l‚Äôensemble du territoire fran√ßais. Si cet outil vous int√©resse ou si vous avez besoin d‚Äôun dispositif de ce type, n‚Äôh√©sitez pas √† me contacter √† l‚Äôadresse suivante : <a href="mailto:contact@gael-maignan.fr">contact@gael-maignan.fr</a> ou sur <a href="https://www.linkedin.com/in/gael-maignan/" target="_blank">LinkedIn</a></div>

    </div>

    <div class="footer">
      <div class="small">Urban Sight ‚Äî Projection WebMercator & isovist 2D</div>
      <div class="small" style="margin-top:6px"><a href="https://www.linkedin.com/in/gael-maignan">Ga√™l Maignan</a></div>
    </div>
  </div>
</div>

<!-- osmtogeojson CDN -->
<script src="https://cdn.jsdelivr.net/npm/osmtogeojson@3.0.0-beta.5/osmtogeojson.min.js"></script>
<script>
/* -- NOTES :
   - Impl√©mente pan & zoom en modifiant la bbox mercator (mercBBox).
   - On stocke les polygones en coordonn√©es WebMercator (m√®tres) dans polygonsMerc,
     puis on reprojette en pixels √† chaque draw (donc tuiles & polygones suivent la vue).
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');









/* ======================
   Arbres
   ====================== */

// ===== Arbres : donn√©es, options et constantes =====
let showTrees = true;                 // contr√¥le d'affichage (li√© √† la checkbox)
let treesGeo = [];                    // features nodes (raw) r√©cup√©r√©es depuis Overpass
let treesMerc = [];                   // arbres convertis en cercles (coord mercator)
const DEFAULT_TREE_CIRCUMFERENCE_M = 1.0; // valeur de r√©f√©rence si pas d'infos (en m√®tres)
const TREE_CANOPY_MULTIPLIER = 3.5;   // transforme rayon de tronc -> rayon de houppier approximatif
const TREE_POLY_SEGMENTS = 18;        // nombre de segments pour approx cercle (collision)

/**
 * Convertit un noeud (lon,lat) + radiusMeters -> polygon ring en coordonn√©es Mercator (m√®tres)
 * renvoie un tableau [{x,y},...]
 */
function createCirclePolygonMerc(lon, lat, radiusMeters, segments = TREE_POLY_SEGMENTS){
  const center = lonLatToMercator(lon, lat);
  const ring = [];
  for(let i=0;i<segments;i++){
    const ang = (i/segments) * Math.PI * 2;
    // approx: 1 meter in mercator is not isotropic but pour petits rayon c'est OK
    const dx = Math.cos(ang) * radiusMeters;
    const dy = Math.sin(ang) * radiusMeters;
    ring.push({ x: center.x + dx, y: center.y + dy });
  }
  return ring;
}

/**
 * D√©duit une "circonf√©rence" en m√®tres √† partir des tags OSM courants.
 * Accept√©: properties.circumference, dbh, diameter, circumference:cm...
 * Retourne circumference en m√®tres.
 */
function parseCircumferenceMeters(props){
  if(!props) return DEFAULT_TREE_CIRCUMFERENCE_M;
  const pick = (k) => (props[k] !== undefined ? String(props[k]).trim() : null);
  let v;
  v = pick('circumference') || pick('circumference:meters') || pick('circumference:m') || pick('circumference:cm');
  if(v){
    let num = parseFloat(v.replace(',', '.'));
    if(isNaN(num) === false){
      // si valeur > 10 -> probablement en cm -> convertir en m
      if(num > 10) num = num / 100;
      return Math.max(0.01, num);
    }
  }
  // dbh (diameter at breast height) souvent en cm
  v = pick('dbh') || pick('diameter') || pick('diameter:cm');
  if(v){
    let num = parseFloat(v.replace(',', '.'));
    if(!isNaN(num)){
      // si dbh > 10 -> en cm -> convertir
      if(num > 10) num = num / 100;
      const circumference = Math.PI * num; // C = œÄD
      return Math.max(0.01, circumference);
    }
  }
  // si rien -> valeur par d√©faut
  return DEFAULT_TREE_CIRCUMFERENCE_M;
}
/* ======================
Fin arbres
   ====================== */








/* ======================
   OPTIM: Offscreen + caches & index
   INS√àRER ICI (apr√®s `const ctx = canvas.getContext('2d');`)
   ====================== */
const offscreenBuildings = document.createElement('canvas'); // utilis√© pour dessiner b√¢timents statiques
const offscreenBuildingsCtx = offscreenBuildings.getContext('2d');

// -----------------------------
// S√©paration Buildings <-> Trees (stockage Mercator & projection)
// -----------------------------
let polygonsMercBuildings = []; // polygones Mercator (b√¢timents / structures)
let polygonsMercTrees = [];     // polygones Mercator (arbres uniquement)
let projectedBuildings = null;  // projection pixels des b√¢timents
let projectedTrees = null;      // projection pixels des arbres
// Note: projectedPolygons sera construit √† partir de ces deux tableaux


let projectedPolygons = null; // pixel-projected polygons (mise √† jour uniquement quand la vue change ou apr√®s fetch)
let segmentsCache = null;      // tableau d'objets {a:{x,y}, b:{x,y}, minX,minY,maxX,maxY} pr√©comput√©s
let lastMercBBoxHash = null;   // pour d√©tecter changement de vue

// Animation / draw control
let needRedrawDynamic = true; // indique qu'il faut redraw dynamique (isovist + curseur)
let scheduledRAF = false;

// helper hashing simple pour mercBBox (tol√©rance)
function hashMercBBox(mb){
  if(!mb) return null;
  // arrondir √† 1 pixel d'√©quivalence pour √©viter redraws mineurs
  const e = 1e-6;
  return `${Math.round(mb.minX/e)}_${Math.round(mb.maxX/e)}_${Math.round(mb.minY/e)}_${Math.round(mb.maxY/e)}`;
}

// quick AABB test
function aabbIntersects(ax1,ay1,ax2,ay2, bx1,by1,bx2,by2){
  return !(bx1 > ax2 || bx2 < ax1 || by1 > ay2 || by2 < ay1);
}
/* ======================
   Fonctions d'optimisation : projection, segments cache, offscreen render
   INS√âRER ICI (apr√®s helpers mercator/pixel)
   ====================== */

function projectPolygonsToPixels(){
  // Projette polygonsMercBuildings -> projectedBuildings (pixels)
  projectedBuildings = polygonsMercBuildings.map(ring => ring.map(m => mercatorToPixel(m.x, m.y)));

  // Projette polygonsMercTrees -> projectedTrees (pixels)
  projectedTrees = polygonsMercTrees.map(ring => ring.map(m => mercatorToPixel(m.x, m.y)));

  // projectedPolygons utilis√© par le reste du code (segmentsCache, rendu non-dynamique...)
  // include trees only if showTrees true
  projectedPolygons = projectedBuildings.concat(showTrees ? projectedTrees : []);
  // (optionnel) tu peux appliquer ici une simplification si n√©cessaire
}


function buildSegmentsCacheFromProjected(){
  // construit segmentsCache = [{a:{x,y}, b:{x,y}, minX,minY,maxX,maxY}, ...]
  const segs = [];
  for(const poly of projectedPolygons){
    for(let i=0;i<poly.length;i++){
      const a = poly[i];
      const b = poly[(i+1)%poly.length];
      const minX = Math.min(a.x,b.x), maxX = Math.max(a.x,b.x);
      const minY = Math.min(a.y,b.y), maxY = Math.max(a.y,b.y);
      segs.push({a:{x:a.x,y:a.y}, b:{x:b.x,y:b.y}, minX, minY, maxX, maxY});
    }
  }
  segmentsCache = segs;
}

function renderBuildingsToOffscreen(){
  if(!projectedBuildings) return;
  const W = canvas.width / DPR, H = canvas.height / DPR;
  offscreenBuildings.width = Math.round(canvas.width);
  offscreenBuildings.height = Math.round(canvas.height);
  const osctx = offscreenBuildingsCtx;
  osctx.clearRect(0,0,offscreenBuildings.width, offscreenBuildings.height);
  osctx.save();
  osctx.scale(DPR, DPR);

  // STYLE B√ÇTIMENTS
  osctx.lineWidth = -2;
  osctx.strokeStyle = 'rgba(44,54,64,0.4)';
  osctx.fillStyle = 'rgba(16,28,38,1)';

  // DESSINER UNIQUEMENT LES B√ÇTIMENTS (projectedBuildings)
  for(const poly of projectedBuildings){
    osctx.beginPath();
    for(let i=0;i<poly.length;i++){
      const p = poly[i];
      if(i===0) osctx.moveTo(p.x,p.y); else osctx.lineTo(p.x,p.y);
    }
    osctx.closePath();
    osctx.fill();
    osctx.stroke();
  }

  // DESSINER LES ARBRES seulement si demand√©
  if(showTrees && projectedTrees && projectedTrees.length){
    osctx.globalCompositeOperation = 'source-over';
    osctx.lineWidth = 0.8;
    osctx.fillStyle = 'rgba(12,90,40,0.95)';     // houppier fonc√©
    osctx.strokeStyle = 'rgba(30,160,100,0.12)'; // contour l√©ger
    for(const t of projectedTrees){
      osctx.beginPath();
      for(let i=0;i<t.length;i++){
        const p = t[i];
        if(i===0) osctx.moveTo(p.x,p.y); else osctx.lineTo(p.x,p.y);
      }
      osctx.closePath();
      osctx.fill();
      osctx.stroke();
    }
  }

  // outlines si voulu (faible co√ªt ici car offscreen)
  if(showPolygonsOutline){
    osctx.lineWidth = 0.9;
    osctx.strokeStyle = 'rgba(255,255,255,0.06)';
    for(const poly of projectedBuildings){
      osctx.beginPath();
      for(let i=0;i<poly.length;i++){
        const p = poly[i];
        if(i===0) osctx.moveTo(p.x,p.y); else osctx.lineTo(p.x,p.y);
      }
      osctx.closePath();
      osctx.stroke();
    }
    // si tu veux outlines arbres, tu pourrais aussi it√©rer projectedTrees lorsque showTrees true
  }

  osctx.restore();
}



/* simple coarse uniform grid would be next-step; for l'instant on utilise
   AABB prefilter + segmentsCache pour √©viter millions d'op√©rations inutiles */

let DPR = Math.min(window.devicePixelRatio || 1, 2);
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width * DPR);
  canvas.height = Math.round(rect.height * DPR);
}
window.addEventListener('resize', () => { resizeCanvas(); draw(); });
resizeCanvas();

// UI elements
const statusEl = document.getElementById('status');
const rayCountEl = document.getElementById('rayCount');
const rayCountLabel = document.getElementById('rayCountLabel');
const maxDistEl = document.getElementById('maxDist');
const maxDistLabel = document.getElementById('maxDistLabel');



// ------ toggle arbres UI hook ------
const toggleTreesEl = document.getElementById('toggleTrees');
if(toggleTreesEl){
  showTrees = toggleTreesEl.checked;
  toggleTreesEl.addEventListener('change', (e) => {
showTrees = !!e.target.checked;

// Recomposer polygonsMerc √† partir des buffers d√©j√† fetch√©s
polygonsMerc = polygonsMercBuildings.concat(showTrees ? polygonsMercTrees : []);

// Reprojection + cache + offscreen
projectPolygonsToPixels();
buildSegmentsCacheFromProjected();
renderBuildingsToOffscreen();
draw();

  });
}





// ---------- Loader DOM refs & helpers (INS√âRER ICI, apr√®s statusEl declaration) ----------
const loaderOverlay = document.getElementById('loaderOverlay');
const loaderTextEl = loaderOverlay ? loaderOverlay.querySelector('.loader-text') : null;
const canvasWrap = document.getElementById('canvasWrap');

function showLoader(text = 'Chargement des b√¢timents‚Ä¶'){
  if(!loaderOverlay) return;
  loaderTextEl && (loaderTextEl.textContent = text);
  loaderOverlay.classList.remove('hidden');
  loaderOverlay.setAttribute('aria-hidden','false');
  // met un indicateur d'√©tat accessible
  if(canvasWrap) canvasWrap.setAttribute('aria-busy','true');
}

function hideLoader(){
  if(!loaderOverlay) return;
  loaderOverlay.classList.add('hidden');
  loaderOverlay.setAttribute('aria-hidden','true');
  if(canvasWrap) canvasWrap.removeAttribute('aria-busy');
}



rayCountLabel.textContent = rayCountEl.value;
maxDistLabel.textContent = maxDistEl.value;

rayCountEl.addEventListener('input', ()=>{ rayCountLabel.textContent = rayCountEl.value; draw(); });
maxDistEl.addEventListener('input', ()=>{ maxDistLabel.textContent = maxDistEl.value; draw(); });

let showRays = false;

const villes = [
  "Brest",
  "Paris",
  "Marseille",
  "Lyon",
  "Lille",
  "Toulouse",
  "Nice",
  "Bordeaux",
  "Nantes",
  "Strasbourg",
  "Grenoble",
];

// Choisir une ville al√©atoire
let adresse = villes[Math.floor(Math.random() * villes.length)];

async function getCenteredBBox(address, halfHeight = 0.0024, halfWidth = 0.0050) {
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;
  const response = await fetchWithRetry(url, { headers: { "User-Agent": "YourApp/1.0" } });
  const data = await response.json();
  if (data.length === 0) throw new Error("Adresse introuvable");
  const lat = parseFloat(data[0].lat);
  const lon = parseFloat(data[0].lon);
  const bbox = { south: lat - halfHeight, north: lat + halfHeight, west: lon - halfWidth, east: lon + halfWidth };
  return { lat, lon, bbox };
}










/* ---------- Search bar behaviour ---------- */
const addressInput = document.getElementById('addressInput');
const addressSearchBtn = document.getElementById('addressSearchBtn');

// pr√©remplir avec valeur par d√©faut si souhait√©
addressInput.value = adresse || '';

// fonction de recentrage sur l'adresse recherch√©e
async function goToAddress(query){
  if(!query || !query.trim()) return;
  const q = query.trim();
  statusEl.textContent = 'Recherche adresse‚Ä¶';
  try {
    const data = await getCenteredBBox(q); // TA fonction existante
    // calcule mercator bbox √† partir de data.bbox
    const sw = lonLatToMercator(data.bbox.west, data.bbox.south);
    const ne = lonLatToMercator(data.bbox.east, data.bbox.north);
    mercBBox = {
      minX: Math.min(sw.x, ne.x),
      maxX: Math.max(sw.x, ne.x),
      minY: Math.min(sw.y, ne.y),
      maxY: Math.max(sw.y, ne.y)
    };

    // placer l'observer au centre de la vue
    const midX = (mercBBox.minX + mercBBox.maxX) / 2;
    const midY = (mercBBox.minY + mercBBox.maxY) / 2;
    const midP = mercatorToPixel(midX, midY);
    observer.x = midP.x; observer.y = midP.y;

    // redraw + fetch b√¢timents pour la nouvelle vue (d√©bounced)
    draw();
    scheduleFetchBuildingsDebounced(200);

    // retourner un message utilisateur
    statusEl.innerHTML = `<span class="success">Centr√©e sur "${escapeHtml(q)}" ‚Äî ${Number(data.lat).toFixed(6)}, ${Number(data.lon).toFixed(6)}</span>`;
    addressInput.blur();
  } catch(err){
    console.warn(err);
    statusEl.innerHTML = `<span class="danger">Adresse introuvable ou erreur.</span>`;
  }
}

// clic sur le bouton
addressSearchBtn.addEventListener('click', ()=>{ goToAddress(addressInput.value || adresse); });

// Enter dans le champ lance la recherche
addressInput.addEventListener('keydown', (e) => {
  if(e.key === 'Enter') {
    e.preventDefault();
    goToAddress(addressInput.value || adresse);
  }
});

// (optionnel) suggestion rapide : clear status quand on √©dite
addressInput.addEventListener('input', ()=>{ if(statusEl) statusEl.textContent = ''; });













// Projection: WebMercator (meters)
const R = 6378137;
function lonLatToMercator(lon, lat){
  const x = R * lon * Math.PI / 180;
  const y = R * Math.log(Math.tan(Math.PI/4 + (lat * Math.PI/180)/2));
  return {x,y};
}
function mercatorToLonLat(mx, my){
  const lon = (mx / R) * 180 / Math.PI;
  const lat = (2 * Math.atan(Math.exp(my / R)) - Math.PI/2) * 180 / Math.PI;
  return { lon, lat };
}

// Variables pour la carte / vue
let mercBBox = null; // {minX,maxX,minY,maxY} en m√®tres (WebMercator)
let mapPadding = 0; // px (CSS px)
let polygonsMerc = []; // tableau de polygones en coordonn√©es mercator (m√®tres)
// polygons (pixels) seront recalcul√©s √† chaque draw
let polygons = []; // pixel version recalcul√©e
let observer = {x: canvas.width/2/DPR, y: canvas.height/2/DPR}; // origine isovist en px (CSS px)
let showPolygonsOutline = true;

// helpers mercator <-> pixel (CSS px)
function mercatorToPixel(mx, my){
  const W = canvas.width / DPR, H = canvas.height / DPR;
  const pad = mapPadding;
  const minX = mercBBox.minX, maxX = mercBBox.maxX, minY = mercBBox.minY, maxY = mercBBox.maxY;
  const sx = (W - pad*2) / (maxX - minX);
  const sy = (H - pad*2) / (maxY - minY);
  const s = Math.min(sx, sy);
  const widthMapped = (maxX - minX) * s;
  const heightMapped = (maxY - minY) * s;
  const offsetX = (W - widthMapped) / 2;
  const offsetY = (H - heightMapped) / 2;
  const px = offsetX + (mx - minX) * s;
  const py = offsetY + (maxY - my) * s;
  return {x: px, y: py};
}
function pixelToMercator(px, py){
  const W = canvas.width / DPR, H = canvas.height / DPR;
  const pad = mapPadding;
  const minX = mercBBox.minX, maxX = mercBBox.maxX, minY = mercBBox.minY, maxY = mercBBox.maxY;
  const sx = (W - pad*2) / (maxX - minX);
  const sy = (H - pad*2) / (maxY - minY);
  const s = Math.min(sx, sy);
  const widthMapped = (maxX - minX) * s;
  const heightMapped = (maxY - minY) * s;
  const offsetX = (W - widthMapped) / 2;
  const offsetY = (H - heightMapped) / 2;
  const mx = minX + (px - offsetX) / s;
  const my = maxY - (py - offsetY) / s;
  return {x: mx, y: my};
}
function getPxPerMeter(){
  const W = canvas.width / DPR, H = canvas.height / DPR;
  const sx = (W - mapPadding*2) / (mercBBox.maxX - mercBBox.minX);
  const sy = (H - mapPadding*2) / (mercBBox.maxY - mercBBox.minY);
  return Math.min(sx, sy);
}

// convert GeoJSON -> polygons en coordonn√©es mercator (m√®tres)
function geojsonToMercatorPolygons(geojson){
  const polys = [];
  for(const feat of geojson.features || []){
    const geom = feat.geometry;
    if(!geom) continue;
    if(geom.type === 'Polygon'){
      const outer = geom.coordinates[0];
      const ring = outer.map(c => {
        const m = lonLatToMercator(c[0], c[1]);
        return {x: m.x, y: m.y};
      });
      if(ring.length >= 3) polys.push(fixPolygonWindingMerc(ring));
    } else if(geom.type === 'MultiPolygon'){
      for(const poly of geom.coordinates){
        const outer = poly[0];
        const ring = outer.map(c => {
          const m = lonLatToMercator(c[0], c[1]);
          return {x: m.x, y: m.y};
        });
        if(ring.length >= 3) polys.push(fixPolygonWindingMerc(ring));
      }
    }
  }
  return polys;
}
function fixPolygonWindingMerc(ring){
  // compute signed area in mercator coords (we'll compute on pixel-equivalent by using coords as-is)
  let area = 0;
  for(let i=0;i<ring.length;i++){
    const a = ring[i], b = ring[(i+1)%ring.length];
    area += (a.x*b.y - b.x*a.y);
  }
  if(area < 0) ring.reverse();
  return ring;
}

/* --------------------
   Isovist simulator adapted
-------------------- */
function getSegmentsFromPolygons(polys){
  const segs = [];
  for(const poly of polys){
    for(let i=0;i<poly.length;i++){
      const a = poly[i];
      const b = poly[(i+1)%poly.length];
      segs.push({a:{x:a.x,y:a.y}, b:{x:b.x,y:b.y}});
    }
  }
  return segs;
}
function intersectRaySeg2(px,py, dirx,diry, x1,y1,x2,y2){
  const ax = x1, ay = y1;
  const bx = x2, by = y2;
  const dx = dirx, dy = diry;
  const vx = bx - ax, vy = by - ay;
  const denom = dx*vy - dy*vx;
  if (Math.abs(denom) < 1e-9) return null;
  const t = ( (ax - px)*vy - (ay - py)*vx ) / denom;
  const u = ( (ax - px)*dy - (ay - py)*dx ) / denom;
  if(t >= 0 && u >= 0 && u <= 1){
    return { x: px + t*dx, y: py + t*dy, t: t, u: u };
  }
  return null;
}
// -------------------------
// Helper : test point in polygon (ray-casting) + test any building
// Ins√®re ceci juste apr√®s `intersectRaySeg2(...)`
// -------------------------
function pointInPolygon(px, py, poly){
  // poly : [{x,y}, ...] en pixels
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x, yi = poly[i].y;
    const xj = poly[j].x, yj = poly[j].y;
    const intersect = ((yi > py) !== (yj > py)) &&
                      (px < (xj - xi) * (py - yi) / (yj - yi + 0.0) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function isPointInAnyBuilding(px, py){
  if(!projectedBuildings || projectedBuildings.length === 0) return false;
  for(const poly of projectedBuildings){
    // bbox rapide
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for(const p of poly){ if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x; if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y; }
    if(px < minX || px > maxX || py < minY || py > maxY) continue;
    if(pointInPolygon(px, py, poly)) return true;
  }
  return false;
}


/* ======================
   computeIsovistFast : utilise segmentsCache & pr√©filtre AABB
   INS√âRER ICI (apr√®s intersectRaySeg2)
   ====================== */
function computeIsovistFast(origin, numRays, maxDist){
  if(!segmentsCache) return computeIsovist(origin, numRays, maxDist); // fallback

  const pts = [];
  // prepare bounding box of ray (toute la zone circulaire) to quickly filter segments
  for(let i=0;i<numRays;i++){
    const ang = (i/numRays) * Math.PI * 2;
    const dx = Math.cos(ang);
    const dy = Math.sin(ang);
    const rayMaxX = origin.x + dx * maxDist;
    const rayMinX = Math.min(origin.x, rayMaxX);
    const rayMaxXX = Math.max(origin.x, rayMaxX);
    const rayMaxY = origin.y + dy * maxDist;
    const rayMinY = Math.min(origin.y, rayMaxY);
    const rayMaxYY = Math.max(origin.y, rayMaxY);

    let nearest = null;
    let nearestT = Infinity;

    // loop over segmentsCache but with AABB prefilter
    for(const s of segmentsCache){
      // quick bbox test (si bbox du segment n'intersecte pas bbox du rayon, skip)
      if(!aabbIntersects(rayMinX, rayMinY, rayMaxXX, rayMaxYY, s.minX, s.minY, s.maxX, s.maxY)) continue;
      const it = intersectRaySeg2(origin.x, origin.y, dx, dy, s.a.x, s.a.y, s.b.x, s.b.y);
      if(it && it.t < nearestT){
        nearestT = it.t;
        nearest = {x: it.x, y: it.y};
      }
    }

    if(nearest){
      const dist = Math.hypot(nearest.x - origin.x, nearest.y - origin.y);
      if(dist > maxDist) pts.push({x: origin.x + dx*maxDist, y: origin.y + dy*maxDist});
      else pts.push(nearest);
    } else {
      pts.push({x: origin.x + dx*maxDist, y: origin.y + dy*maxDist});
    }
  }
  return pts;
}

function computeIsovist(origin, numRays, maxDist){
  const pts = [];
  const segs = getSegmentsFromPolygons(polygons);
  for(let i=0;i<numRays;i++){
    const ang = (i/numRays) * Math.PI * 2;
    const dx = Math.cos(ang);
    const dy = Math.sin(ang);
    let nearest = null;
    let nearestT = Infinity;
    for(const s of segs){
      const it = intersectRaySeg2(origin.x, origin.y, dx, dy, s.a.x, s.a.y, s.b.x, s.b.y);
      if(it && it.t < nearestT){
        nearestT = it.t;
        nearest = {x: it.x, y: it.y};
      }
    }
    if(nearest){
      const dist = Math.hypot(nearest.x - origin.x, nearest.y - origin.y);
      if(dist > maxDist) pts.push({x: origin.x + dx*maxDist, y: origin.y + dy*maxDist});
      else pts.push(nearest);
    } else {
      pts.push({x: origin.x + dx*maxDist, y: origin.y + dy*maxDist});
    }
  }
  return pts;
}

/* --------------------
   Tile background (OpenStreetMap / Carto dark)
-------------------- */
const tileSize = 256; // tile pixel size (CSS px)
const initialResolution = 2 * Math.PI * R / tileSize; // meters per pixel at zoom 0
const tileCache = {}; // url -> Image | 'loading' | 'error'
let mustCaptureTilesOnly = false;
















// snapshot des tuiles (offscreen canvas) utilis√© pendant zoom/pan

let tilesSnapshot = null;              // canvas (device pixels)
let tilesSnapshotMercBBox = null;      // copie du mercBBox correspondant √† ce snapshot

// helpers param√©tr√©s par bbox (utilisent la m√™me logique que tes helpers existants)
function mercatorToPixelGivenBBox(mx, my, bbox){
  const W = canvas.width / DPR, H = canvas.height / DPR;
  const pad = mapPadding;
  const minX = bbox.minX, maxX = bbox.maxX, minY = bbox.minY, maxY = bbox.maxY;
  const sx = (W - pad*2) / (maxX - minX);
  const sy = (H - pad*2) / (maxY - minY);
  const s = Math.min(sx, sy);
  const widthMapped = (maxX - minX) * s;
  const heightMapped = (maxY - minY) * s;
  const offsetX = (W - widthMapped) / 2;
  const offsetY = (H - heightMapped) / 2;
  const px = offsetX + (mx - minX) * s;
  const py = offsetY + (maxY - my) * s;
  return {x: px, y: py};
}
function pixelToMercatorGivenBBox(px, py, bbox){
  const W = canvas.width / DPR, H = canvas.height / DPR;
  const pad = mapPadding;
  const minX = bbox.minX, maxX = bbox.maxX, minY = bbox.minY, maxY = bbox.maxY;
  const sx = (W - pad*2) / (maxX - minX);
  const sy = (H - pad*2) / (maxY - minY);
  const s = Math.min(sx, sy);
  const widthMapped = (maxX - minX) * s;
  const heightMapped = (maxY - minY) * s;
  const offsetX = (W - widthMapped) / 2;
  const offsetY = (H - heightMapped) / 2;
  const mx = minX + (px - offsetX) / s;
  const my = maxY - (py - offsetY) / s;
  return {x: mx, y: my};
}


















// ----------------- contr√¥le du chargement des tuiles -----------------
// Tant que les b√¢timents ne sont pas charg√©s (ou au moins qu'un essai de chargement est
// effectu√©), on ne d√©clenche pas les requ√™tes de tuiles. Cela inverse la logique.
let tilesEnabled = false;


function lonToTileX(lon, z){
  return (lon + 180) / 360 * Math.pow(2, z);
}
function latToTileY(lat, z){
  const latRad = lat * Math.PI / 180;
  return (1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * Math.pow(2, z);
}
function tileXToLon(x, z){
  return x / Math.pow(2,z) * 360 - 180;
}
function tileYToLat(y, z){
  const n = Math.PI - 2 * Math.PI * y / Math.pow(2,z);
  return (180/Math.PI) * Math.atan(0.5*(Math.exp(n) - Math.exp(-n)));
}

function computeZoomFromScale(){
  const W = canvas.width / DPR;
  const minX = mercBBox.minX, maxX = mercBBox.maxX;
  const sx = (W - mapPadding*2) / (maxX - minX);
  const s = sx;
  const approxZ = Math.log2(initialResolution * s);
  let z = Math.round(approxZ);
  z = Math.max(0, Math.min(19, z));
  return z;
}

function drawTiles(){

  if(!mercBBox) return;
    // Si les b√¢timents n'ont pas encore √©t√© r√©cup√©r√©s (flag false),



    // Si tiles d√©sactiv√©es => si on a un snapshot de l'ancienne vue, on l'affiche transform√©
  if (!tilesEnabled) {
    if (tilesSnapshot && tilesSnapshotMercBBox) {
      try {
        // on est dans draw() apr√®s avoir fait ctx.scale(DPR,DPR)
        // calculer o√π les coins du snapshot (ancien) tombent dans la nouvelle vue
        const Wcss = canvas.width / DPR, Hcss = canvas.height / DPR;

        // coin haut-gauche et bas-droit en mercator selon l'ancienne bbox
        const originM = pixelToMercatorGivenBBox(0, 0, tilesSnapshotMercBBox);
        const cornerM = pixelToMercatorGivenBBox(Wcss, Hcss, tilesSnapshotMercBBox);

        // position de ces coins dans la nouvelle vue (CSS px)
        const originNew = mercatorToPixelGivenBBox(originM.x, originM.y, mercBBox);
        const cornerNew = mercatorToPixelGivenBBox(cornerM.x, cornerM.y, mercBBox);

        const destX = originNew.x, destY = originNew.y;
        const destW = cornerNew.x - originNew.x;
        const destH = cornerNew.y - originNew.y;

        // dessiner le snapshot (src en device px, dest en user space CSS px)
        ctx.drawImage(tilesSnapshot,
                      0, 0, tilesSnapshot.width, tilesSnapshot.height,
                      destX, destY, destW, destH);
        return;
      } catch (err) {
        // en cas d'erreur on tombe back sur le comportement standard (aucun snapshot)
        console.warn('Erreur draw snapshot:', err);
      }
    }
    // si pas de snapshot, on tait (on laisse le clear() faire son fond uni)
    return;
  }



  const z = computeZoomFromScale();

  const sw = mercatorToLonLat(mercBBox.minX, mercBBox.minY);
  const ne = mercatorToLonLat(mercBBox.maxX, mercBBox.maxY);

  const txMin = Math.floor(lonToTileX(sw.lon, z));
  const txMax = Math.ceil(lonToTileX(ne.lon, z));
  const tyMin = Math.floor(latToTileY(ne.lat, z));
  const tyMax = Math.ceil(latToTileY(sw.lat, z));

  for(let tx = txMin; tx <= txMax; tx++){
    for(let ty = tyMin; ty <= tyMax; ty++){
      const wrapX = ((tx % Math.pow(2,z)) + Math.pow(2,z)) % Math.pow(2,z);
      const url = `https://a.basemaps.cartocdn.com/dark_all/${z}/${wrapX}/${ty}.png`;
      const tlLon = tileXToLon(tx, z);
      const tlLat = tileYToLat(ty, z);
      const brLon = tileXToLon(tx + 1, z);
      const brLat = tileYToLat(ty + 1, z);
      const tlM = lonLatToMercator(tlLon, tlLat);
      const brM = lonLatToMercator(brLon, brLat);
      const tlP = mercatorToPixel(tlM.x, tlM.y);
      const brP = mercatorToPixel(brM.x, brM.y);
      const dx = tlP.x, dy = tlP.y;
      const dw = brP.x - tlP.x;
      const dh = brP.y - tlP.y;

      ctx.fillStyle = 'rgba(4,10,16,1)';
      ctx.fillRect(dx, dy, dw, dh);

      const cacheKey = url;
      const cached = tileCache[cacheKey];
      if(cached && cached instanceof Image && cached.complete && cached.naturalWidth){
        try { ctx.drawImage(cached, dx, dy, dw, dh); } catch(e) { }
      } else if(cached === 'loading' || cached === 'error'){
        // placeholder already drawn
      } else {
        tileCache[cacheKey] = 'loading';
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.onload = () => { tileCache[cacheKey] = img; draw(); };
        img.onerror = () => { tileCache[cacheKey] = 'error'; };
        img.src = url;
      }
    }
  }
}

/* --------------------
   Drawing
-------------------- */
function clear(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#05111b';
  ctx.fillRect(0,0,canvas.width,canvas.height);
}
function drawGrid(){
  const W = canvas.width/DPR, H = canvas.height/DPR;
  const step = 100;
  ctx.save();
  ctx.scale(DPR, DPR);
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let x=0;x<=W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<=H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.restore();
}

function draw(){
  resizeCanvas();
  clear();
  if(!mercBBox) { ctx.save(); ctx.scale(DPR,DPR); ctx.restore(); return; }

/* ======================
   REMPLACER projection fr√©quente par projection conditionnelle
   (remplace la ligne "polygons = polygonsMerc.map(...)" dans draw())
   ====================== */
if(!polygonsMerc || polygonsMerc.length === 0){
  projectedPolygons = [];
} else {
  // si la bbox mercator (vue) n'a pas chang√© et qu'on a d√©j√† projet√© -> r√©utiliser
  const h = hashMercBBox(mercBBox);
  if(lastMercBBoxHash !== h || !projectedPolygons){
    // projection lourde : faire une fonction s√©par√©e pour pouvoir l'appeler apr√®s fetch ou apr√®s zoom/pan
    projectPolygonsToPixels();
    lastMercBBoxHash = h;
    // reconstruire segmentsCache √† partir de projectedPolygons
    buildSegmentsCacheFromProjected();
    // (re-render buildings offscreen)
    renderBuildingsToOffscreen();
  }
}

  ctx.save();
  ctx.scale(DPR, DPR);

  // draw tiles
  drawTiles();

// blit le canvas offscreen des buildings (si pr√©sent)
if(offscreenBuildings && offscreenBuildings.width && offscreenBuildings.height){
  // drawImage uses device pixels; on a dimensionn√© offscreen en device pixels
  ctx.drawImage(offscreenBuildings, 0, 0, offscreenBuildings.width / DPR, offscreenBuildings.height / DPR);
}


  // Capture uniquement le fond de carte (tuiles)
// apr√®s drawTiles() mais avant buildings/cursor/vision
if (mustCaptureTilesOnly) {
    try {
        tilesSnapshot = document.createElement('canvas');
        tilesSnapshot.width = canvas.width;
        tilesSnapshot.height = canvas.height;
        const sctx = tilesSnapshot.getContext('2d');
        
        // On copie le canvas AVANT les b√¢timents/cursor => donc seulement les tuiles
        sctx.drawImage(canvas, 0, 0);

        // On m√©morise la bbox correspondant √† ce snapshot
        tilesSnapshotMercBBox = {
            minX: mercBBox.minX,
            maxX: mercBBox.maxX,
            minY: mercBBox.minY,
            maxY: mercBBox.maxY
        };
    } catch (err) {
        console.warn('Erreur capture tile-only snapshot:', err);
        tilesSnapshot = null;
        tilesSnapshotMercBBox = null;
    }

    mustCaptureTilesOnly = false; // capture effectu√©e
}
  


  // grid on top
  drawGrid();



// dynamic layer : isovist (calcul√© √† partir des segmentsCache et observer)
const numRays = parseInt(rayCountEl.value,10);
const maxDistMeters = parseFloat(maxDistEl.value, 10) || 0;
let pxPerMeter = getPxPerMeter();
if(!isFinite(pxPerMeter) || pxPerMeter <= 0) pxPerMeter = 1;
let maxDist = maxDistMeters * pxPerMeter;
if(!isFinite(maxDist) || maxDist <= 0) maxDist = 100;

// compute isovist from optimized computeIsovistFast
const isoPts = computeIsovistFast(observer, numRays, maxDist);


// draw observer (avec changement de style si le curseur est DANS un b√¢timent)
const cursorInBuilding = isPointInAnyBuilding(observer.x, observer.y);


// draw isovist
if(isoPts && isoPts.length>2){
  ctx.beginPath();
  ctx.moveTo(isoPts[0].x, isoPts[0].y);
  for(let i=1;i<isoPts.length;i++) ctx.lineTo(isoPts[i].x, isoPts[i].y);
  ctx.closePath();
  const g = ctx.createRadialGradient(observer.x, observer.y, 1, observer.x, observer.y, Math.min(maxDist, Math.hypot(canvas.width,canvas.height)));
    if(!cursorInBuilding){
    g.addColorStop(0, 'rgba(34,193,195,0.38)');
  g.addColorStop(1, 'rgba(34,193,195,0.02)');
  }else {
g.addColorStop(0, 'rgba(255,0,0,0)');
  g.addColorStop(1, 'rgba(255,0,0,0)');
  }
  ctx.fillStyle = g;
  ctx.fill();
  if(!cursorInBuilding){
  ctx.strokeStyle = 'rgba(34,193,195,0.9)';
}else {
  ctx.strokeStyle = 'rgba(255,0,0,0.6)';
}
  ctx.lineWidth = 1.2;
  ctx.stroke();
}


  if(showRays){
    ctx.lineWidth = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    for(const p of isoPts){ ctx.moveTo(observer.x, observer.y); ctx.lineTo(p.x, p.y); }
    ctx.stroke();
  }




// draw observer
ctx.beginPath();
ctx.fillStyle = '#fff';
ctx.arc(observer.x, observer.y, 4, 0, Math.PI*2);
ctx.fill();
ctx.beginPath();
ctx.strokeStyle = '#0b1220';
ctx.lineWidth = 2;
ctx.arc(observer.x, observer.y, 6, 0, Math.PI*2);
ctx.stroke();




ctx.restore();

}

/* --------------------
   Mouse handling: isovist suit la souris
   + pan & zoom
-------------------- */
/* ======================
   Remplacer pointermove -> scheduler rAF (pour √©viter redraws sync excessifs)
   ====================== */
canvas.addEventListener('pointermove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  observer.x = x;
  observer.y = y;

  // ne pas appeler draw() directement : scheduler raf pour la couche dynamique
  needRedrawDynamic = true;
  if(!scheduledRAF){
    scheduledRAF = true;
    requestAnimationFrame(()=>{ scheduledRAF = false; doDynamicRedraw(); });
  }
});

// fonction de redraw dynamique (isovist + curseur)
function doDynamicRedraw(){
  // draw only dynamic parts: uses current offscreenBuildings already blitted in drawBase()
  // we call full draw but it will be cheap because buildings are offscreen
  draw(); // draw() est d√©sormais optimis√© (blit offscreen + dynamic)
  needRedrawDynamic = false;
}

canvas.addEventListener('contextmenu', (e)=>e.preventDefault());



























let fetchAbortController = null;
let fetchDebounceTimer = null;
const FETCH_DEBOUNCE_MS = 350; // d√©lai apr√®s lequel on d√©clenche la requ√™te (apr√®s la derni√®re interaction)
const BBOX_BUFFER_FACTOR = 0.10; // √©tend la bbox de 10% pour charger un peu au-del√† de la vue (pr√©venir les bords)

function getLonLatBBoxFromMercBBox(mb){
  const sw = mercatorToLonLat(mb.minX, mb.minY);
  const ne = mercatorToLonLat(mb.maxX, mb.maxY);
  return { south: sw.lat, west: sw.lon, north: ne.lat, east: ne.lon };
}
function expandMercBBox(mb, factor = BBOX_BUFFER_FACTOR){
  const width = mb.maxX - mb.minX;
  const height = mb.maxY - mb.minY;
  const padX = width * factor;
  const padY = height * factor;
  return {
    minX: mb.minX - padX,
    maxX: mb.maxX + padX,
    minY: mb.minY - padY,
    maxY: mb.maxY + padY
  };
}
function getMercBBoxFromGeojson(geojson){
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(const feat of geojson.features || []){
    const geom = feat.geometry;
    if(!geom) continue;
    const polys = (geom.type === 'Polygon') ? [geom.coordinates] : (geom.type === 'MultiPolygon' ? geom.coordinates : []);
    for(const poly of polys){
      const ring = poly[0];
      for(const coord of ring){
        const lon = coord[0], lat = coord[1];
        const m = lonLatToMercator(lon, lat);
        if(m.x < minX) minX = m.x;
        if(m.x > maxX) maxX = m.x;
        if(m.y < minY) minY = m.y;
        if(m.y > maxY) maxY = m.y;
      }
    }
  }
  if(minX === Infinity) return null;
  return { minX, maxX, minY, maxY };
}

async function fetchBuildingsForView({useViewMercBBox=true, expand=true} = {}){
  if(!mercBBox) {
    statusEl.textContent = 'Impossible : mercBBox non initialis√©e.';
    return;
  }
   // show loader when we start fetching buildings
  showLoader('R√©cup√©ration des b√¢timents pour la vue‚Ä¶');

  // abort previous fetch if en cours
  if(fetchAbortController){
    try{ fetchAbortController.abort(); }catch(_){}
    fetchAbortController = null;
  }
  fetchAbortController = new AbortController();
  const signal = fetchAbortController.signal;

  statusEl.textContent = 'R√©cup√©ration des b√¢timents pour la vue courante‚Ä¶';
  statusEl.className = 'status';

  try{
    // Compose bbox from current view (optionnellement √©tendue)
    const bboxMerc = expand ? expandMercBBox(mercBBox, BBOX_BUFFER_FACTOR) : mercBBox;
    const lonlatBbox = getLonLatBBoxFromMercBBox(bboxMerc);

    const overpassQuery = `[out:json][timeout:60];
(
  way["building"](${lonlatBbox.south},${lonlatBbox.west},${lonlatBbox.north},${lonlatBbox.east});
  relation["building"](${lonlatBbox.south},${lonlatBbox.west},${lonlatBbox.north},${lonlatBbox.east});
  node["natural"="tree"](${lonlatBbox.south},${lonlatBbox.west},${lonlatBbox.north},${lonlatBbox.east});
);
out body;
>;
out skel qt;`;


    const res = await fetchWithRetry('https://overpass-api.de/api/interpreter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' },
      body: 'data=' + encodeURIComponent(overpassQuery),
      signal
    });
    if(!res.ok) throw new Error(`Overpass HTTP ${res.status} ${res.statusText}`);
    const osmJson = await res.json();
    const geojson2 = osmtogeojson(osmJson);

    if(!geojson2 || !geojson2.features || geojson2.features.length === 0){
      statusEl.innerHTML = '<span class="danger">Aucune feature retourn√©e par Overpass pour cette vue.</span>';
      polygonsMerc = [];
      draw();
      return;
    }

    // optional: filter tiny polygons
    // optional: filter tiny polygons (keep Points so trees aren't dropped)
geojson2.features = geojson2.features.filter(f => {
  try {
    if(!f.geometry) return false;
    // keep points (trees) and other non-polygon geometries
    if(f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint' || f.geometry.type === 'LineString') {
      return true;
    }
    // only apply tiny-polygon filter to Polygon / MultiPolygon
    if(f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'){
      const coords = (f.geometry.type === 'Polygon') ? f.geometry.coordinates[0] : f.geometry.coordinates[0][0];
      if(!coords || coords.length < 4) return false;
      let minx=Infinity, miny=Infinity, maxx=-Infinity, maxy=-Infinity;
      for(const c of coords){ minx=Math.min(minx,c[0]); maxx=Math.max(maxx,c[0]); miny=Math.min(miny,c[1]); maxy=Math.max(maxy,c[1]); }
      const bboxArea = (maxx-minx)*(maxy-miny);
      return bboxArea > 1e-9;
    }
    // fallback: keep anything else
    return true;
  } catch(e){
    return true;
  }
});


    // merge touching buildings if mergeTouchingFeatures available
    const mergedGeo = (typeof mergeTouchingFeatures === 'function') ? mergeTouchingFeatures(geojson2) : geojson2;







// --- S√©parer buildings et trees en Mercator ---
polygonsMercBuildings = geojsonToMercatorPolygons(mergedGeo);

// --- EXTRACT TREES (nodes natural=tree) ---
treesGeo = (geojson2.features || []).filter(f => f.geometry && f.geometry.type === 'Point' && f.properties && f.properties['natural'] === 'tree');

// Convertir nodes -> arbres (cercles en mercator) en stockant dans polygonsMercTrees
polygonsMercTrees = treesGeo.map(feat => {
  const [lon, lat] = feat.geometry.coordinates;
  const circM = parseCircumferenceMeters(feat.properties);
  const trunkRadius = circM / (2 * Math.PI); // m
  const canopyRadiusM = Math.max(trunkRadius * TREE_CANOPY_MULTIPLIER, 1.5); // min canopy 1.5m
  return createCirclePolygonMerc(lon, lat, canopyRadiusM, TREE_POLY_SEGMENTS);
});

// Construire polygonsMerc (uniquement pour compatibilit√©/usage ailleurs)
// arbres ajout√©s seulement si showTrees true
polygonsMerc = polygonsMercBuildings.concat(showTrees ? polygonsMercTrees : []);




// PROJECTION + CACHE + OFFSCREEN
projectPolygonsToPixels();
buildSegmentsCacheFromProjected();
renderBuildingsToOffscreen();
needRedrawDynamic = true;


    if(polygonsMerc.length === 0){
      statusEl.innerHTML = '<span class="danger">Conversion OK mais aucun polygon utilisable.</span>';
    } else {
      statusEl.innerHTML = '<span class="success">Charg√© : ' + polygonsMerc.length + ' polygones (unit√©s) pour la vue actuelle.</span>';
      // center observer dans la vue (optionnel) : on conserve la vue, mais recentre l'observer si il √©tait hors √©cran
      const midX = (mercBBox.minX + mercBBox.maxX)/2;
      const midY = (mercBBox.minY + mercBBox.maxY)/2;
      const midP = mercatorToPixel(midX, midY);
      // ne pas forcer si utilisateur a d√©plac√© le curseur ‚Äî seulement si observer est en dehors du canvas
      if(observer.x < 0 || observer.y < 0 || observer.x > canvas.width/DPR || observer.y > canvas.height/DPR){
        observer.x = midP.x; observer.y = midP.y;
      }
      draw();
    }
  } catch(err){
    if(err.name === 'AbortError'){
      console.warn('Fetch Overpass annul√© (nouvelle requ√™te).');
      return;
    }
    console.error(err);
    statusEl.innerHTML = `<span class="danger">Erreur: ${escapeHtml(err.message || String(err))} ‚Äî possible CORS ou indisponibilit√© Overpass.</span>`;
  } finally {
    fetchAbortController = null;
    hideLoader();

    // Activer les tuiles apr√®s la tentative de chargement des b√¢timents
    // (m√™me en cas d'erreur on autorise ensuite le chargement des tuiles).
    if (!tilesEnabled) {
      tilesEnabled = true;
      // on n'a plus besoin du snapshot (les tuiles vont remplacer l'ancien fond)
      tilesSnapshot = null;
      tilesSnapshotMercBBox = null;
      // redraw pour d√©clencher drawTiles() qui lancera alors les chargements d'images
      draw();
    }
  }
}

// Debounce helper (r√©initialise timer)
function scheduleFetchBuildingsDebounced(delay = FETCH_DEBOUNCE_MS){
  if(fetchDebounceTimer) clearTimeout(fetchDebounceTimer);
  fetchDebounceTimer = setTimeout(()=>{ fetchBuildingsForView({useViewMercBBox:true, expand:true}); fetchDebounceTimer = null; }, delay);
}
// Immediate fetch (cancels debounce)
function fetchBuildingsImmediately(){
  if(fetchDebounceTimer) { clearTimeout(fetchDebounceTimer); fetchDebounceTimer = null; }
  fetchBuildingsForView({useViewMercBBox:true, expand:true});
}

/* --- Hook events to trigger fetches at end of interactions --- */

// adapt wheel handler: d√©j√† existant ‚Äî on zoom change, schedule une fetch
// Remplace l'appel de draw() existant dans le handler wheel par draw() + scheduleFetchBuildingsDebounced()
// (dans ton code existant, le draw() est appel√© √† la fin du wheel handler) ‚Äî on ajoute scheduling.
// Exemple : (dans ton handler wheel existant) -> apr√®s modification :
//
// mercBBox.minX = newMinX; mercBBox.maxX = newMaxX;
// mercBBox.minY = newMinY; mercBBox.maxY = newMaxY;
// draw();
// scheduleFetchBuildingsDebounced();
//
// Pour √™tre s√ªr, on actualise le handler wheel ci-dessous (remplace l'ancien) :

// Zoom with wheel (centered on cursor) ‚Äî remplace les autres handlers 'wheel'
// Zoom with wheel (centered on cursor) ‚Äî remplace tout autre handler 'wheel'
// Zoom with wheel (centered on cursor) ‚Äî handler robuste contre le "bounce"
// Wheel handler ‚Äî applique zoom visuel pendant le scroll, fetch only after wheel idle
// --- Remplacer l'ancien wheel handler par celui-ci ---
let _wheelIdleTimer = null;
canvas.addEventListener('wheel', (e) => {
  if (!mercBBox) return;
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;

  // point mercator sous le curseur
  const centerM = pixelToMercator(px, py);

  // facteur de zoom (sensibilit√©)
  const zoomFactor = Math.exp(-e.deltaY * 0.006);
  if (!isFinite(zoomFactor) || zoomFactor <= 0) return;

  const minX = mercBBox.minX, maxX = mercBBox.maxX, minY = mercBBox.minY, maxY = mercBBox.maxY;
  const oldWidth = maxX - minX;

  // calcul des nouvelles bornes en appliquant zoom autour de centerM
  const newMinX = centerM.x - (centerM.x - minX) / zoomFactor;
  const newMaxX = centerM.x + (maxX - centerM.x) / zoomFactor;
  const newMinY = centerM.y - (centerM.y - minY) / zoomFactor;
  const newMaxY = centerM.y + (maxY - centerM.y) / zoomFactor;

  const newWidth = newMaxX - newMinX;

  // 1) si changement relatif trop petit -> probable bounce / micro-mouvement -> ignorer
  const relChange = Math.abs(newWidth - oldWidth) / (oldWidth || 1);
  if (relChange < ZOOM_REL_CHANGE_THRESHOLD) {
    return; // pas d'actualisation visuelle ni fetch
  }

  // 2) limites strictes : si on sortirait des bornes -> ignorer (pas de redraw)
  if (newWidth < MIN_VIEW_WIDTH_METERS) return; // limite zoom avant atteinte
  if (newWidth > MAX_VIEW_WIDTH_METERS) return; // limite d√©zoom atteinte

  // --- IMPORTANT: capture the tiles **before** disabling them and before changing mercBBox ---
  // Indiquer qu'on veut capturer uniquement le fond lors du prochain draw()
  mustCaptureTilesOnly = true;

  // effectuer un draw synchrone *tant que tilesEnabled === true* pour capturer le fond actuel
  draw();

  // maintenant que snapshot a √©t√© cr√©√© par draw(), on peut d√©sactiver les tuiles et appliquer la nouvelle bbox
  tilesEnabled = false;

  // applique les nouvelles bornes (changement significatif et dans les limites)
  mercBBox.minX = newMinX;
  mercBBox.maxX = newMaxX;
  mercBBox.minY = newMinY;
  mercBBox.maxY = newMaxY;

  // redraw imm√©diat pour retour visuel (affiche le snapshot transform√©)
  draw();

  // Reset le timer d'idle : quand l'utilisateur arr√™te de scroller pendant WHEEL_IDLE_DELAY_MS,
  // on d√©clenche un seul fetchBuildingsImmediately().
  if (_wheelIdleTimer) clearTimeout(_wheelIdleTimer);
  _wheelIdleTimer = setTimeout(() => {
    _wheelIdleTimer = null;
    // fetch once after stop
    try { fetchBuildingsImmediately(); } catch (err) { console.warn(err); }
  }, WHEEL_IDLE_DELAY_MS);
}, { passive: false });




// Pan: dans pointerup (fin du drag) on d√©clenche une fetch imm√©diate
// Ton handler pointerup existant doit appeler fetchBuildingsImmediately() si un drag a eu lieu.
// Voici un remplacement / extension minimal de ton pointerup actuel :

canvas.addEventListener('pointerup', (e)=>{
  if(isDragging){
    isDragging = false;
      // capture snapshot au d√©but du drag/pan

    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    // fetch buildings now that pan finished
    fetchBuildingsImmediately();
  }
});

// Dans pointercancel aussi
canvas.addEventListener('pointercancel', (e)=>{
  if(isDragging) {
    isDragging = false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    fetchBuildingsImmediately();
  }
});

// Expose le bouton de r√©cup√©ration pour qu'il d√©clenche la nouvelle fonction
//fetchBtn.removeEventListener && fetchBtn.removeEventListener('click', ()=>{}); // safe remove if any
//fetchBtn.addEventListener('click', ()=>{ fetchBuildingsForView({useViewMercBBox:true, expand:true}); });

function zoomFit(){
  if(!mercBBox) return;
  const midX = (mercBBox.minX + mercBBox.maxX)/2;
  const midY = (mercBBox.minY + mercBBox.maxY)/2;
  const midP = mercatorToPixel(midX, midY);
  observer.x = midP.x; observer.y = midP.y;
  draw();
  scheduleFetchBuildingsDebounced(200);
}

/* --- initial : apr√®s calcul initial de mercBBox on lance un fetch pour remplir la vue --- */
// Remplace le then() existant sur getCenteredBBox(...) en bas de ton script par ceci :
//
// getCenteredBBox(adresse).then(data=>{
//   const sw = lonLatToMercator(data.bbox.west, data.bbox.south);
//   const ne = lonLatToMercator(data.bbox.east, data.bbox.north);
//   mercBBox = { minX: Math.min(sw.x, ne.x), maxX: Math.max(sw.x, ne.x), minY: Math.min(sw.y, ne.y), maxY: Math.max(sw.y, ne.y) };
//   const midP = mercatorToPixel((mercBBox.minX+mercBBox.maxX)/2, (mercBBox.minY+mercBBox.maxY)/2);
//   observer.x = midP.x; observer.y = midP.y;
//   draw();
//   // fetch initial buildings for this view
//   fetchBuildingsForView({useViewMercBBox:true, expand:true});
// }).catch(err => { console.warn(err); draw(); });
//
// (ou simplement cliquer sur "R√©cup√©rer b√¢timents" apr√®s le chargement



// Pan with pointer drag
let isDragging = false;
let dragStart = null;
let dragStartBBox = null;

canvas.addEventListener('pointerdown', (e)=>{
  if(!mercBBox) return;
  // start pan on primary button
  if(e.button !== 0) return;
  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  isDragging = true;
  dragStart = {x: px, y: py};
  dragStartBBox = {minX: mercBBox.minX, maxX: mercBBox.maxX, minY: mercBBox.minY, maxY: mercBBox.maxY};
  canvas.setPointerCapture(e.pointerId);

  // capture tile-only snapshot before user starts panning
mustCaptureTilesOnly = true;
draw();           // draw synchronously while tilesEnabled is still true
tilesEnabled = false; // puis d√©sactiver le chargement de nouvelles tuiles pendant le drag
// on garde dragStartBBox etc. comme tu as d√©j√†
});
canvas.addEventListener('pointerup', (e)=>{
  if(isDragging){
    isDragging = false;
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
  }
});
canvas.addEventListener('pointercancel', (e)=>{
  if(isDragging) { isDragging = false; try{ canvas.releasePointerCapture(e.pointerId); }catch(_){} }
});
canvas.addEventListener('pointermove', (e)=>{
  // if dragging (pan) override observer update above (pointermove handler already sets observer)
  if(!isDragging || !dragStartBBox) return;
  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  const dx = px - dragStart.x;
  const dy = py - dragStart.y;
  const s = getPxPerMeter();
  if(!isFinite(s) || s === 0) return;
  // pan: for X: move bbox by -dx/s ; for Y: move bbox by +dy/s (see analyse)
  mercBBox.minX = dragStartBBox.minX - dx / s;
  mercBBox.maxX = dragStartBBox.maxX - dx / s;
  mercBBox.minY = dragStartBBox.minY + dy / s;
  mercBBox.maxY = dragStartBBox.maxY + dy / s;
  draw();
});

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// initial: compute bbox around adresse and draw empty map
getCenteredBBox(adresse).then(data=>{
  const sw = lonLatToMercator(data.bbox.west, data.bbox.south);
  const ne = lonLatToMercator(data.bbox.east, data.bbox.north);
  mercBBox = { minX: Math.min(sw.x, ne.x), maxX: Math.max(sw.x, ne.x), minY: Math.min(sw.y, ne.y), maxY: Math.max(sw.y, ne.y) };
  // set observer to center
  const midP = mercatorToPixel((mercBBox.minX+mercBBox.maxX)/2, (mercBBox.minY+mercBBox.maxY)/2);
  observer.x = midP.x; observer.y = midP.y;
  draw();
}).catch(err => { console.warn(err); draw(); });







/* ---------- Initialisation apr√®s chargement complet de la page ---------- */
window.addEventListener('load', async () => {
  try {
    statusEl.textContent = 'Initialisation de la carte‚Ä¶';
    // attendre les polices si besoin (utile si tu utilises web fonts)
    if (document.fonts && document.fonts.ready) await document.fonts.ready;

    // s'assurer du bon sizing du canvas apr√®s rendu CSS
    resizeCanvas();

    // obtenir la bbox centr√©e sur l'adresse par d√©faut
    const data = await getCenteredBBox(adresse);
    const sw = lonLatToMercator(data.bbox.west, data.bbox.south);
    const ne = lonLatToMercator(data.bbox.east, data.bbox.north);
    mercBBox = {
      minX: Math.min(sw.x, ne.x),
      maxX: Math.max(sw.x, ne.x),
      minY: Math.min(sw.y, ne.y),
      maxY: Math.max(sw.y, ne.y)
    };

    // positionner l'observer au centre de la vue
    const midX = (mercBBox.minX + mercBBox.maxX) / 2;
    const midY = (mercBBox.minY + mercBBox.maxY) / 2;
    const midP = mercatorToPixel(midX, midY);
    observer.x = midP.x; observer.y = midP.y;

    // premier rendu
    draw();

    // r√©cup√©rer les b√¢timents pour la vue initiale (d√©bounced ou imm√©diat selon pr√©f√©rence)
    // --> fetchBuildingsForView({useViewMercBBox:true, expand:true});


    // je recommande le fetch pour la vue actuelle (expansion incluse)
    await fetchBuildingsForView({useViewMercBBox:true, expand:true});

    statusEl.innerHTML = '<span class="success">Initialisation termin√©e.</span>';
  } catch (err) {
    console.warn('Initialisation carte √©chou√©e :', err);
    statusEl.innerHTML = `<span class="danger">Initialisation √©chou√©e ‚Äî ${escapeHtml(err.message || String(err))}</span>`;
    // dessiner la carte vide si erreur
    draw();
  }
});

</script>

</body>
</html>